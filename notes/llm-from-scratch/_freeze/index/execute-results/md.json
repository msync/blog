{
  "hash": "2b70b92829cd43a44ee8978a89afb854",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Notes: LLM From Scratch\"\ndate: 2024-08-10\nsummary: \"Notes and pointers during the exploration of the book LLM From Scratch by Sebastian Raschka. Comprehensive exploration of tokenization, embeddings, and building language models from scratch.\"\ntags: [\"machine-learning\", \"llm\", \"deep-learning\", \"python\", \"pytorch\", \"tokenization\"]\ncategories: [\"notes\"]\ndraft: false\ntoc: true\nnumber-sections: false\npage-layout: article\nsidebar: true\nbibliography: references.bib\nengine: jupyter\njupyter: kg-llm-from-scratch\nexecute:\n  daemon: false\n  cache: true\n  freeze: auto\nformat:\n  hugo-md:\n    output-file: index.md\n    preserve-yaml: true\n    toc: false\n    code-fold: false\n    code-summary: \"Click to expand/collapse\"\n    code-tools: true\n    code-line-numbers: true\n---\n\n# Synopsis\n\nNotes and pointers during the exploration of the book [LLM From Scratch](https://www.manning.com/books/build-a-large-language-model-from-scratch) by [Sebastian Raschka](https://github.com/rasbt). While I am using this book as the central reference, the notes will contain additional references and pointers to other resources.\n\n# Chapter 1: Understanding Large Language Models {#sec-chapter-1}\n\n- A good quality corpus is crucial.\n- Choice of corpus will depend on the downstream tasks.\n- For example, to generate code, the corpus should contain a substantial amount of code snippets.\n\nAn open-source corpus of 3 trillion tokens has been detailed in [@dolma2024].\n\n## Key challenges in pre-training\n  - Data: Creating or curating a large corpus of text data is a significant challenge. The quality and diversity of the data are crucial for the performance of the model.\n  - Model: The model architecture is key for pre-training. A good model architecture will help in learning the underlying structure of the data.\n  - Budget: Pre-training a large language model requires a lot of computational resources. A good budget is crucial for pre-training.\n  - [GPT-3](https://en.wikipedia.org/wiki/GPT-3) potentially cost $4.6 million to train, per @gpt3technicaloverview.\n\n@instruct-gpt presented ideas on how to fine-tune GPT-3 on a dataset of instructions.\n\n\n# Chapter 2: Working with text data\n\nFor a brief overview of tokens and embeddings in the context of deep learning text models, see [LLMs: Understanding Tokens and Embeddings](https://msync.org/notes/llm-understanding-tokens-embeddings/)\n\nThere can be \n- Standalone models just for embeddings (eg: Word2Vec [see @mikolov2013efficientestimationwordrepresentations], GloVe [see @pennington2014glove]), or\n- Models that use embeddings as part of a larger model (eg: BERT [see @devlin2018bert], GPT-3 [see @brown2020language]).\n\n::: {.callout-note collapse=\"true\"}\nEmbeddings from one model are typically not directly compatible with another model, because the embeddings are learned in the context of the model.\n:::\n\n## Tokenization\nThe more tokens we have, the more information we can capture. However, more tokens also mean more computational resources.\n\n\n::: {.callout-note collapse=\"true\"}\n### How does the token vocabulary affect computation?\n- The number of tokens affects the size of the embedding matrix.\n- The embedding matrix is a lookup table that maps each token to its corresponding embedding vector.\n- The size of the embedding matrix is determined by the vocabulary size and the embedding dimension. The larger the vocabulary, the larger the embedding matrix, and the more memory and computation are required to process it.\n:::\n\n- Tokens can be created not just for words, but also for subwords and characters.\n- This allows us to capture more information, and handle \"words\" not seen before.\n- We do not encode grammar rules (which are hard to define and may not be exhaustive or easy to update). Instead, we let the model learn the rules from the data. This is a key difference between traditional NLP and deep learning NLP.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport importlib\nimport stage1.tokenization\nimportlib.reload(stage1.tokenization)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n<module 'stage1.tokenization' from '/Users/jaju/github/knowledge-garden/content/notes/llm-from-scratch/stage1/tokenization.py'>\n```\n:::\n:::\n\n\n### V1\nThe first, naive implementation that can not handle unseen tokens, as tokens are identified based on word boundaries from the training text.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nstage1.tokenization.v1()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-green-fg\">2025-09-20 09:09:36.107</span> | <span class=\"ansi-bold\">INFO    </span> | <span class=\"ansi-cyan-fg\">utils.downloaders</span>:<span class=\"ansi-cyan-fg\">download</span>:<span class=\"ansi-cyan-fg\">21</span> - <span class=\"ansi-bold\">data/the_verdict.txt already exists. Skipping download.</span>\n</pre>\n```\n:::\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nError: Token 'draggees' not found in vocab.\n```\n:::\n:::\n\n\n### V2\nAbility to handle unseen tokens, plus additional signals to like begin/end of text, padding, etc. We simply preprocess the text to handle unseen tokens and replace then with a special token.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nstage1.tokenization.v2()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-green-fg\">2025-09-20 09:09:36.112</span> | <span class=\"ansi-bold\">INFO    </span> | <span class=\"ansi-cyan-fg\">utils.downloaders</span>:<span class=\"ansi-cyan-fg\">download</span>:<span class=\"ansi-cyan-fg\">21</span> - <span class=\"ansi-bold\">data/the_verdict.txt already exists. Skipping download.</span>\n</pre>\n```\n:::\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n╒═════════╤════════════════════════════╕\n│ Input   │ three she draggees equally │\n├─────────┼────────────────────────────┤\n│ Encoded │ [1004, 876, 1131, 394]     │\n├─────────┼────────────────────────────┤\n│ Decoded │ three she <|unk|> equally  │\n╘═════════╧════════════════════════════╛\n```\n:::\n:::\n\n\n### V3 - Byte Pair Encoding (BPE)\n- Used in the original ChatGPT as well as GPT-2 and GPT-3. \n  - This one goes further granular in how it identifies tokens - encompassing all atomic units and then certain agglomerations of them.- This is a data-driven approach to tokenization, where we learn the tokens from the data.\n- [tiktoken](https://github.com/openai/tiktoken) is a Python implementation of BPE. Implementation from scratch is not a key aim of this book, but it is useful to understand the concepts.\n\nIn this example, we don't create a new vocabulary, but use the 'GPT-2' vocabulary. (See source)\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nstage1.tokenization.v3()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-green-fg\">2025-09-20 09:09:36.116</span> | <span class=\"ansi-bold\">INFO    </span> | <span class=\"ansi-cyan-fg\">utils.downloaders</span>:<span class=\"ansi-cyan-fg\">download</span>:<span class=\"ansi-cyan-fg\">21</span> - <span class=\"ansi-bold\">data/the_verdict.txt already exists. Skipping download.</span>\n</pre>\n```\n:::\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n╒═════════╤════════════════════════════════════╕\n│ Input   │ three she draggees equally         │\n├─────────┼────────────────────────────────────┤\n│ Encoded │ [15542, 673, 6715, 469, 274, 8603] │\n├─────────┼────────────────────────────────────┤\n│ Decoded │ three she draggees equally         │\n╘═════════╧════════════════════════════════════╛\n```\n:::\n:::\n\n\nNotice that the number of tokens is more than the number of distinct words in this example. We also have unseen words, which are split into multiple tokens that are in the vocabulary. This is a key feature of BPE, as it allows us to handle unseen words by breaking them down into smaller units that are in the vocabulary.\n\n### V4 \nThis is a further improvement over the previous version. \"Improvement\" not because of the tokenization technique but because of how we inject special symbols into the text. We use a special token to indicate the beginning and end of a sentence, and a special token to indicate padding.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nstage1.tokenization.v4()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-green-fg\">2025-09-20 09:09:36.219</span> | <span class=\"ansi-bold\">INFO    </span> | <span class=\"ansi-cyan-fg\">utils.downloaders</span>:<span class=\"ansi-cyan-fg\">download</span>:<span class=\"ansi-cyan-fg\">21</span> - <span class=\"ansi-bold\">data/the_verdict.txt already exists. Skipping download.</span>\n</pre>\n```\n:::\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n╒═════════╤═══════════════════════════════════════════════════════════════════════════════╕\n│ Input   │ three she dragged equally. <|endoftext|> This is the end of the document.     │\n├─────────┼───────────────────────────────────────────────────────────────────────────────┤\n│ Encoded │ [15542, 673, 17901, 8603, 13, 220, 50256, 770, 318, 262, 886, 286, 262, 3188, │\n│         │ 13]                                                                           │\n├─────────┼───────────────────────────────────────────────────────────────────────────────┤\n│ Decoded │ three she dragged equally. <|endoftext|> This is the end of the document.     │\n╘═════════╧═══════════════════════════════════════════════════════════════════════════════╛\n```\n:::\n:::\n\n\n#### BPE: A further demonstration\nBPE can handle (apparently) garbage text. And also, it preserves spaces between tokens, because it makes no special assumptions about the text, including the notion of word boundaries.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nstage1.tokenization.v4bpe()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n╒═════════╤═════════════════════════════════════════════════════════════════════════════════╕\n│ Input   │ asd asdjfkjsdf ksjfksa sdkfjsj   powiuosadoapofqfvv                             │\n├─────────┼─────────────────────────────────────────────────────────────────────────────────┤\n│ Encoded │ [292, 67, 355, 28241, 69, 74, 8457, 7568, 479, 82, 73, 69, 591, 64, 264, 34388, │\n│         │ 69, 8457, 73, 220, 220, 7182, 16115, 418, 4533, 499, 1659, 80, 69, 25093]       │\n├─────────┼─────────────────────────────────────────────────────────────────────────────────┤\n│ Decoded │ asd asdjfkjsdf ksjfksa sdkfjsj   powiuosadoapofqfvv                             │\n╘═════════╧═════════════════════════════════════════════════════════════════════════════════╛\n```\n:::\n:::\n\n\n## Embeddings\n\n- Tokens as 1-hot vectors create sparse matrices that are inefficient and fail to capture semantic relationships\n- Embeddings represent tokens in a lower-dimensional space that preserves semantic relationships\n- Embeddings are learned, not universal representations, and are specific to the model they're trained in\n- The embedding space dimension is a tunable hyperparameter (larger = more informative but more resource-intensive)\n- Embeddings start as random values and are refined during training through gradient updates\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport importlib\nimport stage1.embeddings\nimportlib.reload(stage1.embeddings)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n<module 'stage1.embeddings' from '/Users/jaju/github/knowledge-garden/content/notes/llm-from-scratch/stage1/embeddings.py'>\n```\n:::\n:::\n\n\n### What do they look like?\nLet's create a randomly initialized embedding matrix for a vocabulary of size 10 and an embedding dimension of 4. The embeddings matrix is then of size (10, 4), where each row corresponds to a token in the vocabulary and each column corresponds to a dimension in the embedding space.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport torch\nimport stage1.embeddings\nembedding_dim = 4\nvocab_size = 10\n\nembeddings = torch.nn.Embedding(vocab_size, embedding_dim)\nprint(embeddings.weight)\nprint(f\"Embedding of token-id 2 is {embeddings(torch.tensor([1]))}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParameter containing:\ntensor([[-9.9448e-02, -1.1365e-01, -6.4670e-01,  1.3754e+00],\n        [-1.7200e-03, -1.2643e+00, -1.5873e+00,  1.9216e+00],\n        [-1.8102e-01,  7.2387e-01,  1.6446e+00,  1.5566e+00],\n        [-2.0930e-01,  5.7910e-01, -8.7329e-01,  4.8594e-01],\n        [-3.7975e-01,  9.9947e-01,  1.2793e+00, -1.0777e+00],\n        [ 1.8252e+00, -5.2073e-01,  9.4681e-01,  4.4129e-01],\n        [ 2.0121e+00,  3.1196e-01, -1.1323e-01, -8.9150e-01],\n        [-6.9310e-01, -1.2825e+00, -5.1667e-01,  1.5186e+00],\n        [ 8.8475e-02, -1.3853e+00,  3.2707e-01, -2.2567e+00],\n        [-7.8447e-01, -1.1544e+00,  6.3983e-01, -1.6529e+00]],\n       requires_grad=True)\nEmbedding of token-id 2 is tensor([[-1.7200e-03, -1.2643e+00, -1.5873e+00,  1.9216e+00]],\n       grad_fn=<EmbeddingBackward0>)\n```\n:::\n:::\n\n\nThe embedding of a token with id `i` is simply the `i`-th row of the embedding matrix. For example, the embedding of the token with id 0 is the first row of the embedding matrix. Mapping tokens to embeddings is plainly a lookup operation.\n\n### V0\nPrinting the embedding matrix of a made-up vocabulary. The embeddings are randomly initialized.\nThe embeddings matrix size is determined by the vocabulary size and the embedding dimension. The embedding dimension is a hyperparameter that can be tuned.\n\nEmbeddings are tensors with a shape of (vocab_size, embedding_dim).\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nimport torch.nn as nn\nnn.Embedding(10, 4).weight\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nParameter containing:\ntensor([[ 1.1944,  1.4964, -0.2055,  1.3608],\n        [ 0.0955, -0.1670,  0.7993, -1.2934],\n        [-0.4193, -0.6237,  0.4504, -0.5121],\n        [ 0.2605, -0.1577,  0.8277, -1.0529],\n        [ 1.0344,  0.3868, -0.1455,  0.3573],\n        [-0.2662,  0.7649, -0.6125, -0.4384],\n        [-1.0989, -0.0393,  0.3866,  0.1433],\n        [-0.0861, -0.4805, -0.1692,  2.3211],\n        [-0.3632, -0.9352,  0.9874,  0.1108],\n        [-1.2629,  0.1632, -1.8517, -0.7092]], requires_grad=True)\n```\n:::\n:::\n\n\nOnce we have the embeddings matrix, we can map input tokens to their corresponding embeddings.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nstage1.embeddings.v0()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPseudo-randomly initialized embedding layer:\n╒══════════════════════════╤══════════════════════════════════════════════════════════════════════════════╕\n│ Vocab Size               │ 10                                                                           │\n├──────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Output Dimension         │ 3                                                                            │\n├──────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Embedding Layer          │ Embedding(10, 3)                                                             │\n├──────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Layer Weights            │ Parameter containing: tensor([[-1.1258, -1.1524, -0.2506],         [-0.4339, │\n│                          │ 0.8487,  0.6920],         [-0.3160, -2.1152,  0.3223],         [-1.2633,     │\n│                          │ 0.3500,  0.3081],         [ 0.1198,  1.2377, -0.1435],         [-0.1116,     │\n│                          │ -0.6136,  0.0316],         [-0.4927,  0.2484,  0.4397],         [ 0.1124,    │\n│                          │ -0.8411, -2.3160],         [-0.1023,  0.7924, -0.2897],         [ 0.0525,    │\n│                          │ 0.5229,  2.3022]], requires_grad=True)                                       │\n├──────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤\n│ Embedding for token_id 5 │ tensor([-0.1116, -0.6136,  0.0316], grad_fn=<EmbeddingBackward0>)            │\n╘══════════════════════════╧══════════════════════════════════════════════════════════════════════════════╛\n╒═══════════════════════════════════╤═══════════════════════════════════════════════════════════════════════════╕\n│ Embedding for token_ids [2, 4, 6] │ tensor([[-0.3160, -2.1152,  0.3223],         [ 0.1198,  1.2377, -0.1435], │\n│                                   │ [-0.4927,  0.2484,  0.4397]], grad_fn=<EmbeddingBackward0>)               │\n╘═══════════════════════════════════╧═══════════════════════════════════════════════════════════════════════════╛\n```\n:::\n:::\n\n\n### V1\n\n- Data loaders create batches of token-ids for efficient processing\n- Batching is valuable for large text corpora\n- Batched processing leverages GPU acceleration when available\n- Even on CPU, batching enables more efficient multi-threaded processing\n- The example demonstrates creating embeddings for \"The Verdict\" text using previously created data loader with batch processing\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nstage1.embeddings.v1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n╒════════════════╤═══════╕\n│ vocab_size     │ 50257 │\n├────────────────┼───────┤\n│ embedding_size │   256 │\n├────────────────┼───────┤\n│ input_length   │     4 │\n├────────────────┼───────┤\n│ batch_size     │     8 │\n╘════════════════╧═══════╛\nEmbedding Layer: Parameter containing:\ntensor([[ 0.9383,  0.4889, -0.6731,  ...,  1.2948,  1.4628, -0.6204],\n        [ 0.6257, -1.2231, -0.6232,  ...,  0.3260,  0.5352,  1.9733],\n        [-1.4115, -1.0295,  0.1267,  ...,  0.5027, -0.8871,  1.9974],\n        ...,\n        [ 0.6928, -0.5382, -0.8726,  ..., -0.5148,  0.9695,  0.7689],\n        [-0.5866,  0.6971,  1.8386,  ...,  0.4298, -0.5139,  1.6624],\n        [ 0.6073,  0.2991,  0.7669,  ..., -1.3811, -1.4284, -0.5630]],\n       requires_grad=True)\nInputs shape: torch.Size([8, 4])\nTargets shape: torch.Size([8, 4])\nInput tensor shape:  torch.Size([1, 4])\nInput Tensor: tensor([[39936, 24254,  7996, 42174]])\nOutput tensor shape:  torch.Size([1, 4, 256])\nOutput Tensor: tensor([[[-0.9905,  0.4149, -0.1217,  ...,  2.3362, -0.5502,  0.3072],\n         [ 2.0188,  0.2669, -0.0151,  ..., -0.1302,  0.0308, -0.0452],\n         [ 1.7518,  1.2162, -1.0058,  ..., -1.2053, -0.8477, -0.3506],\n         [ 0.3572, -1.6816,  1.1135,  ...,  0.8234,  0.5311, -0.3427]]],\n       grad_fn=<EmbeddingBackward0>)\n```\n:::\n:::\n\n\n### Aside: What Do The Layers and Operations Do?\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nvocab_size = 512\nembeddings_size = 8\ndummy_token_ids = torch.arange(vocab_size)\nembeddings_layer = torch.nn.Embedding(vocab_size, embeddings_size)\n\n# Print the first 4 embeddings out of `vocab_size` - corresponding to the first 4 token ids\nprint(embeddings_layer(torch.arange(4)))\n# Print the token-id 3 (4th token). Note it is just the last tensor of the previous output\nprint(embeddings_layer(torch.tensor(3)))\n\n\n# Position embeddings layer\ncontext_length = 8\noutput_dim = embeddings_size\n# Randomly initialized but not our current concern\npos_embeddings_layer = torch.nn.Embedding(context_length, output_dim)\nprint(pos_embeddings_layer)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntensor([[ 0.7480,  2.0246,  0.8172, -0.6008, -0.9860,  1.7485,  0.3155, -0.7663],\n        [ 0.0486,  0.3841,  0.6013,  1.2091,  0.7474,  1.2037, -0.5525, -0.5882],\n        [ 0.9393,  2.0120,  0.7987, -0.0642, -0.0212,  0.2408, -1.3335, -2.3596],\n        [ 0.4245, -1.2994, -0.8715, -0.1588, -0.8418,  1.3300, -0.2200, -0.4653]],\n       grad_fn=<EmbeddingBackward0>)\ntensor([ 0.4245, -1.2994, -0.8715, -0.1588, -0.8418,  1.3300, -0.2200, -0.4653],\n       grad_fn=<EmbeddingBackward0>)\nEmbedding(8, 8)\n```\n:::\n:::\n\n\n### V2 - Using word positions\n\n* Taking the previous example and thinking further, while embeddings capture semantic relationships in a denser space, we also need to encode token positions in sentences.\n  * A word's meaning can change based on its position\n  * A sentence's meaning can change based on word order\n  * We hypothesize this and hope our neural network architecture will learn it\n\n* We'll abstract away the details of position encoding implementation:\n  * No clean notion of position exists (no defined start/end for text we process)\n  * Focus on the current input and calculations relative to it\n\n* Even within the current input batch, position is a hazy concept due to sliding windows:\n  * Options include using absolute positions within current sequence/batch\n  * Or encoding relative positions instead\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nstage1.embeddings.v2pos()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n╒════════════════╤═══════╕\n│ vocab_size     │ 50257 │\n├────────────────┼───────┤\n│ embedding_size │   256 │\n├────────────────┼───────┤\n│ input_length   │     4 │\n├────────────────┼───────┤\n│ batch_size     │     8 │\n╘════════════════╧═══════╛\nEmbedding Layer: Parameter containing:\ntensor([[-0.7690,  1.6553, -0.7893,  ..., -0.6867, -0.2874, -0.3671],\n        [ 0.8989,  0.8925, -0.3567,  ..., -0.1085,  0.1085, -0.6313],\n        [ 0.2561,  0.1745, -0.0582,  ..., -0.6859,  0.5682, -1.6920],\n        ...,\n        [-1.4095, -0.0738,  0.0833,  ...,  0.2731, -0.4048,  0.7096],\n        [ 0.7286, -0.1222, -0.2912,  ..., -0.9472,  1.4767,  0.2563],\n        [ 1.0063, -1.2769, -0.8027,  ..., -0.8209, -0.4761,  0.5803]],\n       requires_grad=True)\nPositional Embedding Layer: Parameter containing:\ntensor([[-0.9512,  0.4695,  0.0280,  ..., -1.0012, -1.7668, -1.7920],\n        [-0.1993,  0.4765,  0.0246,  ...,  1.4640, -0.5069,  1.0845],\n        [ 1.4029, -1.0208, -0.0899,  ..., -1.2818, -0.1527, -0.1735],\n        [ 0.9177,  1.3376,  1.4023,  ..., -0.9248,  0.3450, -1.5700]],\n       requires_grad=True)\nInput shape:  torch.Size([8, 4, 256])\nPlain token embeddings:  tensor([[[-1.0169e-01, -2.8884e-03,  6.7786e-02,  ..., -1.4209e+00,\n           3.5037e-01, -2.3330e-01],\n         [ 1.3920e+00,  5.9468e-02,  2.6447e-01,  ..., -1.1079e+00,\n          -4.8958e-01, -9.2617e-01],\n         [ 7.3564e-01,  2.8131e-01, -7.7062e-01,  ...,  3.4536e-02,\n          -7.3732e-01,  9.5018e-01],\n         [ 4.0259e-01,  6.2462e-01, -1.2347e+00,  ..., -1.6737e-02,\n          -1.2412e+00, -1.1772e+00]],\n\n        [[-3.4561e-01,  8.8373e-02,  1.2933e+00,  ..., -2.6212e+00,\n           3.0364e+00, -2.3153e-02],\n         [ 1.1975e+00, -8.2988e-01,  3.2502e-01,  ...,  1.2352e+00,\n           1.5225e+00, -8.3964e-01],\n         [-1.4959e-01, -3.8170e-01,  7.7954e-01,  ...,  1.2170e+00,\n           1.3088e-02,  8.1160e-01],\n         [ 1.3594e+00, -6.7180e-02, -1.4525e+00,  ...,  8.3537e-01,\n          -7.4209e-01, -1.0441e+00]],\n\n        [[ 1.5813e+00, -1.1984e+00,  6.5373e-01,  ..., -2.3055e-02,\n          -9.5937e-01,  2.7789e-01],\n         [ 1.6993e+00,  1.0975e+00,  1.3544e-01,  ...,  7.4869e-01,\n           4.8076e-01,  9.3548e-01],\n         [-1.3745e+00, -9.8519e-02, -3.4389e-01,  ...,  6.4930e-01,\n          -8.8472e-01,  1.0561e+00],\n         [-9.4417e-01, -8.7664e-01, -1.2534e+00,  ...,  1.1642e+00,\n          -3.8781e-01,  4.7189e-01]],\n\n        ...,\n\n        [[ 4.0259e-01,  6.2462e-01, -1.2347e+00,  ..., -1.6737e-02,\n          -1.2412e+00, -1.1772e+00],\n         [ 1.2422e+00,  2.1564e+00, -5.3766e-02,  ...,  1.9843e-02,\n          -1.7387e+00,  3.6680e-01],\n         [ 1.1095e+00, -1.8102e+00, -5.0129e-01,  ...,  6.6180e-01,\n          -1.1181e+00, -2.5616e-01],\n         [ 2.7070e-01,  8.6201e-01, -4.7629e-01,  ...,  4.3038e-02,\n           8.6910e-02,  1.9684e+00]],\n\n        [[-2.9615e-01,  2.9772e-01,  1.5972e-01,  ...,  1.3382e-01,\n          -1.6013e+00, -5.4816e-01],\n         [ 4.1694e-01,  5.9602e-02,  1.4777e-01,  ...,  9.9320e-03,\n           1.4118e+00, -1.1616e+00],\n         [-9.3665e-01, -1.5489e-01,  9.6246e-01,  ..., -9.2383e-02,\n           2.2189e-01, -2.0200e-01],\n         [-3.9775e-01,  8.9565e-01, -2.8307e-01,  ...,  5.8753e-01,\n           3.4892e-01,  5.4884e-01]],\n\n        [[-3.5788e+00,  2.9069e-01,  1.8510e-01,  ..., -7.8466e-01,\n           3.6996e-01, -4.4498e-01],\n         [ 2.9396e-01,  2.9446e-01,  7.0959e-01,  ...,  8.4308e-01,\n           1.3235e+00,  9.8919e-01],\n         [-1.2524e+00,  2.1871e+00,  6.8456e-01,  ..., -6.1270e-01,\n          -6.3723e-01, -8.0530e-02],\n         [-6.2119e-01,  1.5308e-01,  1.1285e+00,  ..., -1.3810e+00,\n          -3.9482e-01, -1.2915e+00]]], grad_fn=<EmbeddingBackward0>)\nPositional embeddings:  tensor([[[-1.0529,  0.4666,  0.0958,  ..., -2.4221, -1.4164, -2.0253],\n         [ 1.1927,  0.5360,  0.2890,  ...,  0.3561, -0.9965,  0.1583],\n         [ 2.1385, -0.7395, -0.8605,  ..., -1.2473, -0.8901,  0.7767],\n         [ 1.3203,  1.9622,  0.1676,  ..., -0.9415, -0.8962, -2.7471]],\n\n        [[-1.2968,  0.5579,  1.3213,  ..., -3.6224,  1.2696, -1.8152],\n         [ 0.9982, -0.3534,  0.3496,  ...,  2.6992,  1.0155,  0.2448],\n         [ 1.2533, -1.4025,  0.6897,  ..., -0.0648, -0.1397,  0.6381],\n         [ 2.2771,  1.2704, -0.0502,  ..., -0.0894, -0.3971, -2.6140]],\n\n        [[ 0.6300, -0.7289,  0.6817,  ..., -1.0242, -2.7261, -1.5141],\n         [ 1.5000,  1.5740,  0.1600,  ...,  2.2127, -0.0262,  2.0200],\n         [ 0.0283, -1.1193, -0.4338,  ..., -0.6325, -1.0375,  0.8826],\n         [-0.0264,  0.4609,  0.1489,  ...,  0.2394, -0.0428, -1.0981]],\n\n        ...,\n\n        [[-0.5487,  1.0941, -1.2067,  ..., -1.0179, -3.0080, -2.9692],\n         [ 1.0429,  2.6329, -0.0292,  ...,  1.4838, -2.2457,  1.4513],\n         [ 2.5123, -2.8310, -0.5912,  ..., -0.6200, -1.2709, -0.4296],\n         [ 1.1884,  2.1996,  0.9260,  ..., -0.8817,  0.4319,  0.3984]],\n\n        [[-1.2474,  0.7672,  0.1877,  ..., -0.8674, -3.3680, -2.3402],\n         [ 0.2176,  0.5361,  0.1723,  ...,  1.4739,  0.9049, -0.0772],\n         [ 0.4662, -1.1757,  0.8726,  ..., -1.3742,  0.0691, -0.3755],\n         [ 0.5200,  2.2332,  1.1192,  ..., -0.3372,  0.6939, -1.0211]],\n\n        [[-4.5300,  0.7602,  0.2131,  ..., -1.7858, -1.3968, -2.2370],\n         [ 0.0946,  0.7710,  0.7342,  ...,  2.3071,  0.8166,  2.0737],\n         [ 0.1504,  1.1663,  0.5947,  ..., -1.8945, -0.7900, -0.2540],\n         [ 0.2965,  1.4907,  2.5308,  ..., -2.3057, -0.0498, -2.8615]]],\n       grad_fn=<AddBackward0>)\n```\n:::\n:::\n\n\n# Temporary Section\n\n::: {.panel-tabset data-react-island=\"Tabs\" markdown=\"1\"}\n## Python\n<div data-tab=\"Python\" id=\"py\">\n\n```python\nprint(42)\n```\n\n</div>\n\n## C++\n<div data-tab=\"C++\" id=\"cpp\">\n\n```cpp\n#include <iostream>\nint main(){ std::cout << 42; }\n```\n\n</div>\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}